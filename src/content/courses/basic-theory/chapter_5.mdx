# Where is the code actually located?

We have learned that the lock and type fields of the cell are used to lock the box and to guarantee its ownership and control.

Lock is a script structure that looks like this:

```ts
Script: {
  code_hash: HexString
  args: HexString
  hash_type: Uint8, there are three allowed values: {0: "data", 1: "type", 2: "data1"}
}
```

You may notice that the `code_hash` is not the actual code, but some kind of index of the code. This index allows us to retrieve the code. So, where is the code anyway?

The answer is simple: the code is stored in another cell!

We know that the data field of a cell can contain arbitrary data, so we can put the real code in the data field of another cell and implement this cell as a dependency to a transaction. This dependency cell is called `CellDep` (dep cell).

Depending on the value of `hash_type`, `code_hash` has different interpretations:
- If hash_type is "data" or "data1", code_hash should match the blake2b hash of data in a dep cell;
- If hash_type is "type", code_hash should instead match the type script hash of a dep cell.

When unlocking a cell, we simply import the dep cell, and CKB will follow the above rules to find the corresponding code.

So why not just put in the real code, but use this indexing approach?

One of the major advantages of this design is that if everyone needs the same type of lock, the lock code will be identical, and so will the code_hash value. Then it is just a matter of introducing the same dep cell rather than deploying the same code all over again for each case.

Here's a real example.

CKB has an important built-in smart contract called [SECP256K1_BLAKE160](https://pudge.explorer.nervos.org/scripts#secp256k1_blake160). It is the common lock used by many cells in regular transfer transactions. A cell using this lock is protected by the SECP256K1 encryption algorithm.

To achieve this, CKB created several cells in the genesis block and then put the specific code of the SECP256K1 encryption algorithm into the data field of [these cells](https://github.com/nervosnetwork/rfcs/blob/master/rfcs/0024-ckb-genesis-script-list/0024-ckb-genesis-script-list.md#secp256k1blake160). During the transaction, these cells are introduced as dep cells. Then we fill in the code_hash with the hash of the dep cell's type script while putting our public key hash in the args field, so the lock can determine whether the signature attached to a transfer transaction is authentic and valid.

But at this point, another question may come to your mind.
